# hl<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Package Tracker</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" />
  <style>
    #map { height: 100vh; }
    .package-icon {
      background-image: url('https://cdn-icons-png.flaticon.com/512/715/715676.png');
      background-size: cover;
      width: 32px;
      height: 32px;
    }
    button { margin-right: 5px; padding: 5px 10px; }
  </style>
</head>
<body>
  <div id="map"></div>
  <div style="position: absolute; top: 10px; left: 10px; z-index: 1000;">
    <button id="playBtn">Play</button>
    <button id="pauseBtn">Pause</button>
    <button id="resetBtn">Reset</button>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"></script>
  <script>
    const map = L.map('map').setView([30.2672, -97.7431], 5);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 18 }).addTo(map);

    const packageIcon = L.divIcon({ className: 'package-icon' });
    const texasCoords = [30.2672, -97.7431]; 
    const floridaCoords = [25.7617, -80.1918]; 
    const marker = L.marker(texasCoords, { icon: packageIcon }).addTo(map);

    let animationId = null;
    let paused = true;
    let step = 0;
    let path = [];

    function getBezierPoints(start, control, end, numPoints = 200) {
      const points = [];
      for (let t = 0; t <= 1; t += 1 / numPoints) {
        const lat = (1 - t) ** 2 * start[0] + 2 * (1 - t) * t * control[0] + t ** 2 * end[0];
        const lng = (1 - t) ** 2 * start[1] + 2 * (1 - t) * t * control[1] + t ** 2 * end[1];
        points.push([lat, lng]);
      }
      return points;
    }

    function getBearing(start, end) {
      const lat1 = start[0] * Math.PI / 180;
      const lat2 = end[0] * Math.PI / 180;
      const dLng = (end[1] - start[1]) * Math.PI / 180;
      const y = Math.sin(dLng) * Math.cos(lat2);
      const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLng);
      const brng = Math.atan2(y, x) * 180 / Math.PI;
      return brng;
    }

    const control = [(texasCoords[0] + floridaCoords[0]) / 2 + 3, (texasCoords[1] + floridaCoords[1]) / 2];
    path = getBezierPoints(texasCoords, control, floridaCoords, 200);
    L.polyline(path, { color: 'blue', dashArray: '5,5' }).addTo(map);

    function animate() {
      if (paused) return;
      if (step >= path.length - 1) step = 0;
      marker.setLatLng(path[step]);
      const angle = getBearing(path[step], path[step + 1]);
      marker.getElement().style.transform = `rotate(${angle}deg)`;
      step++;
      animationId = requestAnimationFrame(animate);
    }

    document.getElementById('playBtn').addEventListener('click', () => {
      if (paused) { paused = false; animate(); }
    });

    document.getElementById('pauseBtn').addEventListener('click', () => {
      paused = true;
      if (animationId) cancelAnimationFrame(animationId);
    });

    document.getElementById('resetBtn').addEventListener('click', () => {
      paused = true;
      if (animationId) cancelAnimationFrame(animationId);
      step = 0;
      marker.setLatLng(texasCoords);
      marker.getElement().style.transform = `rotate(0deg)`;
    });
  </script>
</body>
</html>This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

# This workflow lets you generate SLSA provenance file for your project.
# The generation satisfies level 3 for the provenance requirements - see https://slsa.dev/spec/v0.1/requirements
# The project is an initiative of the OpenSSF (openssf.org) and is developed at
# https://github.com/slsa-framework/slsa-github-generator.
# The provenance file can be verified using https://github.com/slsa-framework/slsa-verifier.
# For more information about SLSA and how it improves the supply-chain, visit slsa.dev.

name: SLSA generic generator
on:
  workflow_dispatch:
  release:
    types: [created]

jobs:
  build:
    runs-on: ubuntu-latest
    outputs:
      digests: ${{ steps.hash.outputs.digests }}

    steps:
      - uses: actions/checkout@v4 

      # ========================================================
      #
      # Step 1: Build your artifacts.
      #
      # ========================================================
      - name: Build artifacts
        run: |
            # These are some amazing artifacts.
            echo "artifact1" > artifact1
            echo "artifact2" > artifact2

      # ========================================================
      #
      # Step 2: Add a step to generate the provenance subjects
      #         as shown below. Update the sha256 sum arguments
      #         to include all binaries that you generate
      #         provenance for.
      #
      # ========================================================
      - name: Generate subject for provenance
        id: hash
        run: |
          set -euo pipefail

          # List the artifacts the provenance will refer to.
          files=$(ls artifact*)
          # Generate the subjects (base64 encoded).
          echo "hashes=$(sha256sum $files | base64 -w0)" >> "${GITHUB_OUTPUT}"

  provenance:
    needs: [build]
    permissions:
      actions: read   # To read the workflow path.
      id-token: write # To sign the provenance.
      contents: write # To add assets to a release.
    uses: slsa-framework/slsa-github-generator/.github/workflows/generator_generic_slsa3.yml@v1.4.0
    with:
      base64-subjects: "${{ needs.build.outputs.digests }}"
      upload-assets: true # Optional: Upload to a new release
